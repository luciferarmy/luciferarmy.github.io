<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[博客终于搭建起来了,Hello World!]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再议减少HTTP请求]]></title>
    <url>%2F2018%2F08%2F14%2Freduce-http-requests%2F</url>
    <content type="text"><![CDATA[最近参加了IMWEB前端技术沙龙活动，有幸能站到讲台上，将性能方面的经验与大家分享。现将“再议减少HTTP请求”部分简单摘剪成文。 前言:关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精… 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议减少HTTP请求：“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。 a. 没有浏览器缓存减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。 b. 没有cdn缓存这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。 c. 不能按需加载为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。 d. 浏览器预解析DNS失效现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。 最佳实践因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。 Demo1 必应 首次内联CSS与JS 将资源取出，并保存在localStorage中 资源名（版本）保存在cookie中 后续请求中，服务器检查对应的cookie 根据cookie的值，只嵌入新的脚本 加载时，从localStorage里载入资源 Demo2 百度(移动端) 首次将静态资源打包，用jsonp统一返回 将资源解析并保存在localStorage中 再次访问时检查localStorage中资源情况 如有缺失再发请求获取资源 必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。 我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>html5</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx能为前端开发带来什么？]]></title>
    <url>%2F2018%2F08%2F03%2Fnginx-in-fe%2F</url>
    <content type="text"><![CDATA[Nginx那么好，我想去看看。接连逛了两个书城后，我发现并没有Nginx相关的书籍。这就很奇怪！ Nginx，一名网红（网络服务器红人…），就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。 后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。后来发现了原因，大概是因为“使用太简单了，都不值得出书”。是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。当它呈现到你面前时，感觉独具匠心。 Nginx与NodeJs（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。） 有人说，作为一名前端，我的真爱是NodeJs。同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。 这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。 在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。 合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。 以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。 场景一：环境切换前端开发中，经常面临多个部署环境切换的问题。我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 然而在拓展性和易用性方面，还不足够好。而Nginx作为反向代理，就很容易处理资源转发的问题。 思路很简单： 读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址； 如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）; 123456789set $env_id &quot;1.1.1.1&quot;;if ( $http_cookie ~* &quot;host_id=(\S+)(;.*|$)&quot;) &#123; set $env_id $1;&#125;location / &#123; proxy_set_header Host $host; proxy_pass http://$env_id:80;&#125; 那接下来的事情，就是怎样用最简便的方式，把IP种在cookie里？我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。 这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。 切换环境，如今只需点击一次。 场景二：SourceMap在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。 而SourceMap正好可以解决此问题。 在最新的各版本浏览器里，如果满足： 压缩后的js文件后面有//# sourceMappingURL=xxx.map格式的注释 浏览器能正常访问到sourceMappingURL 那么，就能把压缩过的代码还原。要实现这样的功能，就必须： 现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑） 测试环境带注释，能访问sourceMap 这样的模型，用反向代理+内容纂改的思路再合适不过。每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加.map后缀。随后，使用Nginx，通过这几行配置就能把此功能实现： 1234location ~ \.js$ &#123; footer &quot;\n//# sourceMappingURL=$request_uri.map&quot;; footer_types &quot;*&quot;;&#125; 只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。 场景三：内容纂改其实在以上两个场景里，都涉及了“内容纂改”。无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。 统一介绍下，Nginx涉及纂改的模块有： nginx_http_footer_filter：往文件的底部添加文字，可包含Nginx的内置变量； nginx_http_addition_module：从一个url去读取内容，将之添加到文件的头部或顶部； nginx_http_sub_module：替换字符 除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。单单针对移动web前端开发，就可以实现： 将weinre脚本插入到html里，让移动web调试更加便捷。 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等 场景四：本地映射在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。 比如：线上接口映射到本地文件。想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。 而且，我们可以做得更灵活，比如： 同时支持慢速调试 同时支持目录层级映射 同时支持正则匹配 JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据 这些场景，只运用到Nginx里的“rewrite规则”。从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 最简单的模型中，我们把所有带cgi-bin路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，仅需这三行配置即可：123location ~ /cgi-bin/* &#123; rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;&#125; 后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 场景五：移动侧调试Fiddler 有一个勾选项 Allow remote computers to connect，并可以指定 listen port 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 hosts 配合会很实用。 这个功能，用Nginx也很容易做到。通过 default_server 作为代理，手机终端通过设置网络代理为本机IP和相应的 listen port，从而可以访问本机的 Web 服务。 其中也是用到了ngx_http_proxy_module模块的配置：12345678910111213141516171819202122 server &#123; listen 80 default_server; server_name localhost; resolver 8.8.8.8; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://$host; &#125;&#125;server &#123; listen 80; server_name ke.qq.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:9091/; &#125;&#125; 边角料除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。 1.nginx_http_concat资源合并，处理CDN combo。例如通过这样的方式http://example.com/??style1.css,style2.css,foo/style3.css访问合并后的资源。 2.ngx_http_image_filter_module图片处理。提供图片缩放，jpg压缩，旋转等特性。 3.适配PC与移动web总体可运用ngx_http_proxy_module，去实现路径转发。判断平台类型的Nginx配置，在开源项目detectmobilebrowsers中可以找到。 后记学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。但既然是工具，熟手就好。 比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。 话说回来，后来心情有些惆怅。想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。不过我又想，既然我已经花了时间去写，为什么还要花时间去用？！ 心情又好起来了。（等等有什么不对，管它呢…） END.]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易“聚合阅读”布局的实现]]></title>
    <url>%2F2018%2F05%2F03%2Fmy-news-reader-box%2F</url>
    <content type="text"><![CDATA[网易聚合阅读的出现的确让人惊艳了一下。流畅的交互,使碎片化的新闻资讯像报纸一样摊在眼前,这是信息大爆炸的时代产物。不管你能不能接受这种新阅读形式，事实上，每天越来越多的新闻层出不穷，还没被人看到就已成为了“旧闻”。回归报纸的版面设计，堆叠新闻模块，让用户告别一条接一条整齐的新闻链接，而是在一个版面上提供更多的信息，不失为一种尝试。 而抛去产品的层面，从前端方向来看，“聚合阅读”也有许多值得学习的地方。这几天研究了一下源码，谈谈它随机布局的实现，以及一些优化的措施。 ##demo 点击按钮可以改变布局： ##一.怎样定义格子对象 每个格子对象，都至少应该有这5个属性： left：距离左边界的位置 top：距离上边界的位置 width：格子宽度 height：格子高度 background：格子颜色 逐个去定义对象无疑是愚蠢的：12345678910111213141516171819function Block(o)&#123; return&#123; left: o.left, top: o.top, width: o.width, height: o.height, bg: o.bg &#125;&#125;var block1 = new Block(&#123; left: 0, top: 0, width: 50, height: 50, bg: "#3f3"&#125;);var block2 = ……var block37 = … 这样不仅不利于后期维护，而且构造格子的嵌套关系也相对麻烦。 网易的做法是使用“交替切割”的方式来做： 将大块先切成两列。 左列（红色部分）再切成三行，右列（褐，黄，蓝部分）也切成三行。 对形成的6个小块，再进行列的切割 整个做法就是“列-行-列-行-……”这样的交替切割。所以它的对象是这样设置的,其中random属性可以约定同级的cols或rows是否可以随机变换位置，width和height的值是规定一个父级块的分割比例。其设置的形式例如（例子与demo的设定无关）：12345678910111213141516171819202122232425262728293031323334window.tagConfig.pageLayout = &#123; top: 0, left: 0, width: 100, height: 100, random: !1, cols: [&#123; width: 30, rows: [&#123; height: 40, cols: [&#123; width: 30, rows:[&#123; height:100 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;] &#125;, &#123; height: 30 &#125;,&#123; height: 30 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;]&#125; ##二.递归调用切割函数12345678910111213141516171819function _getGrids(tag) &#123; /*domArr是拥有left,top,width,height,bg等属性的所有dom数组，_getGrids的最终目的就是生成这个数组*/ var domArr = [], _cutGrid(tag.pageLayout, function(tag) &#123; if (tag.rows || tag.cols) &#123; /*假如子级存在rows或者cols，则递归切割*/ _cutGrid(tag, arguments.callee); &#125; else &#123; /*子级不存在rows或者cols，不再进行切割，构造domArr*/ … domArr.push(xxx) … &#125; &#125; ); return domArr;&#125; ##三.切割函数 切割函数挺有意思的，下次想再用一篇文章来详细写一下，在这里仅贴出参考的源码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*对象复制函数*/function _shadowClone(e) &#123; var t = &#123;&#125;; for (var n in e) e.hasOwnProperty(n) &amp;&amp; (t[n] = e[n]); return t;&#125;/*判断子块随机布局与否*/(function() &#123; function ranOrNot(e, t) &#123; var n = []; typeof t == "undefined" &amp;&amp; (t = e, e = 0); for (; e &lt; t; e++) n.push(e); return n &#125; /*随机布局*/ Array.prototype.randomEach = function(t) &#123; console.log(3); if (typeof t != "function") throw new TypeError; var n = this.length, r = ranOrNot(n); while (n) &#123; var i = Math.floor(Math.random() * n--); if (t(this[r[i]]) === !1) break; r[i] = r[n] &#125; &#125;, /*常规布局*/ Array.prototype.forEach || (Array.prototype.forEach = function(e) &#123; var t = this.length; if (typeof e != "function") throw new TypeError; var n = arguments[1]; for (var r = 0; r &lt; t; r++) r in this &amp;&amp; e.call(n, this[r], r, this) &#125;)&#125; )();/*切割函数*/function _cutGrid(tag, funcJudge) &#123; function a(a) &#123; function h(cutLength) &#123; /*复制子块对象并计算出子块top,left*/ var u, a = _shadowClone(cutLength); c++, u = c === l ? tag[cutType2.measure] - s: Math.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / 100), a[cutType1.offset] = i + tag[cutType1.offset], a[cutType2.offset] = s + tag[cutType2.offset], a[cutType1.measure] = f, a[cutType2.measure] = u, a.colorPattern = tag.colorPattern, /*判断小块是否还需要分割*/ funcJudge(a), s += u &#125; var f, l = a[cutType2.name].length, c = 0; u++, f = u === cutLength ? tag[cutType1.measure] - i: Math.floor(a[cutType1.measure] * tag[cutType1.measure] / 100), a.random === !1 ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h), s = 0, i += f &#125; /*根据大块是否有rows属性，定义两种切割方式*/ var cutType1, cutType2; tag.rows ? (cutType1 = &#123; name: "rows", measure: "height", offset: "top" &#125;, cutType2 = &#123; name: "cols", measure: "width", offset: "left" &#125;) : (cutType1 = &#123; name: "cols", measure: "width", offset: "left" &#125;, cutType2 = &#123; name: "rows", measure: "height", offset: "top" &#125;); var i = 0, s = 0, cutLength = tag[cutType1.name].length, u = 0; /*是否随机布局*/ tag.random === !1 ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a)&#125; ##四.最后完成到这一步，我已不记得声明对象时出了多少次错误。各种尖括号，方括号，逗号和分号翩翩起舞时，你一定跟我一样很想念coffee的语法糖…]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
