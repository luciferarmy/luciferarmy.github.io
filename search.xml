<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/23/hello-world/"/>
      <url>/2018/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>博客终于搭建起来了,Hello World!</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再议减少HTTP请求</title>
      <link href="/2018/08/14/reduce-http-requests/"/>
      <url>/2018/08/14/reduce-http-requests/</url>
      <content type="html"><![CDATA[<p><img src="/assets/blogImg/reduce-http.jpg" alt="沙龙分享">       </p><blockquote><p>最近参加了IMWEB前端技术沙龙活动，有幸能站到讲台上，将性能方面的经验与大家分享。现将“再议减少HTTP请求”部分简单摘剪成文。</p></blockquote><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>关于web性能，有两个著名论断：              </p><ol><li><strong>0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力</strong>——Robert Miller                               </li><li><strong>用户所接受的数据，有80~90%的时间都耗在前端上</strong>——Steve Souders</li></ol><p>前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精…</p><p>后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。</p><h3 id="再议减少HTTP请求："><a href="#再议减少HTTP请求：" class="headerlink" title="再议减少HTTP请求："></a>再议减少HTTP请求：</h3><p>“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。</p><p><strong>a. 没有浏览器缓存</strong><br>减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。</p><p><strong>b. 没有cdn缓存</strong><br>这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。</p><p><strong>c. 不能按需加载</strong><br>为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。</p><p><strong>d. 浏览器预解析DNS失效</strong><br>现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。</p><p><strong>Demo1 必应</strong>               </p><blockquote><ol><li>首次内联CSS与JS<ol start="2"><li>将资源取出，并保存在localStorage中</li><li>资源名（版本）保存在cookie中</li><li>后续请求中，服务器检查对应的cookie</li><li>根据cookie的值，只嵌入新的脚本</li><li>加载时，从localStorage里载入资源</li></ol></li></ol></blockquote><p><strong>Demo2 百度(移动端)</strong>               </p><blockquote><ol><li>首次将静态资源打包，用jsonp统一返回<ol start="2"><li>将资源解析并保存在localStorage中</li><li>再次访问时检查localStorage中资源情况</li><li>如有缺失再发请求获取资源</li></ol></li></ol></blockquote><p>必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。              </p><p>我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。<br>你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。</p>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html5 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx能为前端开发带来什么？</title>
      <link href="/2018/08/03/nginx-in-fe/"/>
      <url>/2018/08/03/nginx-in-fe/</url>
      <content type="html"><![CDATA[<p>Nginx那么好，我想去看看。<br>接连逛了两个书城后，我发现并没有Nginx相关的书籍。<br>这就很奇怪！</p><p><img src="/assets/blogImg/nginx0.jpg" alt=""></p><p>Nginx，一名<strong>网红</strong>（网络服务器红人…），就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。</p><p>后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为<strong>“使用太简单了，都不值得出书”</strong>。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。</p><a id="more"></a><h3 id="Nginx与NodeJs"><a href="#Nginx与NodeJs" class="headerlink" title="Nginx与NodeJs"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p><p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。                </p><p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。              </p><p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。               </p><p>合理分配各自<strong>擅长</strong>的事情，这样的思路，同样可以运用于前端开发中。                </p><p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。                  </p><h3 id="场景一：环境切换"><a href="#场景一：环境切换" class="headerlink" title="场景一：环境切换"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 </p><p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。                 </p><p>思路很简单：</p><blockquote><ol><li>读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；</li><li>如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set $env_id &quot;1.1.1.1&quot;;</span><br><span class="line">if ( $http_cookie ~* &quot;host_id=(\S+)(;.*|$)&quot;) &#123;</span><br><span class="line">    set $env_id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_pass   http://$env_id:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那接下来的事情，就是<strong>怎样用最简便的方式，把IP种在cookie里？</strong><br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p><p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src="/assets/blogImg/nginx1.jpg" alt=""></p><p>切换环境，如今只需点击一次。</p><h3 id="场景二：SourceMap"><a href="#场景二：SourceMap" class="headerlink" title="场景二：SourceMap"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p><p>而SourceMap正好可以解决此问题。</p><p>在最新的各版本浏览器里，如果满足：</p><ol><li>压缩后的js文件后面有<code>//# sourceMappingURL=xxx.map</code>格式的注释</li><li>浏览器能正常访问到sourceMappingURL</li></ol><p>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</p><ol><li>现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）</li><li>测试环境带注释，能访问sourceMap</li></ol><p>这样的模型，用<code>反向代理+内容纂改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map</code>后缀。随后，使用Nginx，通过这几行配置就能把此功能实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.js$ &#123;</span><br><span class="line">    footer &quot;\n//# sourceMappingURL=$request_uri.map&quot;;</span><br><span class="line">    footer_types &quot;*&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src="/assets/blogImg/nginx2.jpg" alt=""></p><h3 id="场景三：内容纂改"><a href="#场景三：内容纂改" class="headerlink" title="场景三：内容纂改"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p><p>统一介绍下，Nginx涉及纂改的模块有：</p><ul><li><a href="https://m.oschina.net/blog/156826" target="_blank" rel="noopener">nginx_http_footer_filter</a>：往文件的底部添加文字，可包含Nginx的内置变量；</li><li><a href="http://nginx.org/en/docs/http/ngx_http_addition_module.html" target="_blank" rel="noopener">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li><li><a href="http://nginx.org/en/docs/http/ngx_http_sub_module.html" target="_blank" rel="noopener">nginx_http_sub_module</a>：替换字符</li></ul><p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现： </p><blockquote><ol><li>将<a href="http://people.apache.org/~pmuellr/weinre-docs/latest/" target="_blank" rel="noopener">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li><li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li><li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li></ol></blockquote><h3 id="场景四：本地映射"><a href="#场景四：本地映射" class="headerlink" title="场景四：本地映射"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   </p><p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           </p><p>而且，我们可以做得更灵活，比如：</p><ul><li>同时支持慢速调试</li><li>同时支持目录层级映射</li><li>同时支持正则匹配</li><li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li></ul><p>这些场景，只运用到Nginx里的“<a href="http://www.linuxidc.com/Linux/2014-01/95493.htm" target="_blank" rel="noopener">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 </p><p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /cgi-bin/* &#123;</span><br><span class="line">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 </p><h3 id="场景五：移动侧调试"><a href="#场景五：移动侧调试" class="headerlink" title="场景五：移动侧调试"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p><p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p><p>其中也是用到了<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>模块的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen  80 default_server;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://$host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name  ke.qq.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://127.0.0.1:9091/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="边角料"><a href="#边角料" class="headerlink" title="边角料"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p><p>1.<a href="https://github.com/alibaba/nginx-http-concat" target="_blank" rel="noopener">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p><p>2.<a href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html" target="_blank" rel="noopener">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p><p>3.适配PC与移动web<br>总体可运用<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href="http://detectmobilebrowsers.com/" target="_blank" rel="noopener">detectmobilebrowsers</a>中可以找到。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。 </p><p>比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p><p>话说回来，后来心情有些惆怅。<br>想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。<br>不过我又想，<strong>既然我已经花了时间去写，为什么还要花时间去用？！</strong> </p><p>心情又好起来了。（等等有什么不对，管它呢…）</p><hr><p>END.</p>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网易“聚合阅读”布局的实现</title>
      <link href="/2018/05/03/my-news-reader-box/"/>
      <url>/2018/05/03/my-news-reader-box/</url>
      <content type="html"><![CDATA[<p><img src="/assets/blogImg/myReader0.jpg" alt="聚合阅读">   </p><p>网易<a href="http://news.tag.163.com/" target="_blank" rel="noopener">聚合阅读</a>的出现的确让人惊艳了一下。流畅的交互,使碎片化的新闻资讯像报纸一样摊在眼前,这是信息大爆炸的时代产物。不管你能不能接受这种新阅读形式，事实上，每天越来越多的新闻层出不穷，还没被人看到就已成为了“旧闻”。回归报纸的版面设计，堆叠新闻模块，让用户告别一条接一条整齐的新闻链接，而是在一个版面上提供更多的信息，不失为一种尝试。</p><p>而抛去产品的层面，从前端方向来看，“聚合阅读”也有许多值得学习的地方。这几天研究了一下源码，谈谈它随机布局的实现，以及一些优化的措施。</p><p>##<strong>demo</strong></p><p>点击按钮可以改变布局：<br><a id="more"></a></p><iframe id="demoIframe" src="/assets/demo/my_news_reader/index.html" width="600" height="420" scrolling="no"></iframe><p>##<strong>一.怎样定义格子对象</strong></p><p>每个格子对象，都至少应该有这5个属性：   </p><ul><li>left：距离左边界的位置         </li><li>top：距离上边界的位置           </li><li>width：格子宽度             </li><li>height：格子高度            </li><li>background：格子颜色        </li></ul><p>逐个去定义对象无疑是愚蠢的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Block</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">left: o.left,</span><br><span class="line">top: o.top,</span><br><span class="line">width: o.width,</span><br><span class="line">height: o.height,</span><br><span class="line">bg: o.bg</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> block1 = <span class="keyword">new</span> Block(&#123;</span><br><span class="line">left: <span class="number">0</span>,</span><br><span class="line">top: <span class="number">0</span>,</span><br><span class="line">width: <span class="number">50</span>,</span><br><span class="line">height: <span class="number">50</span>,</span><br><span class="line">bg: <span class="string">"#3f3"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> block2 = …</span><br><span class="line">…</span><br><span class="line"><span class="keyword">var</span> block37 = …</span><br></pre></td></tr></table></figure></p><p>这样不仅不利于后期维护，而且构造格子的嵌套关系也相对麻烦。</p><p>网易的做法是使用“交替切割”的方式来做：         </p><ol><li>将大块先切成两列。         </li><li>左列（红色部分）再切成三行，右列（褐，黄，蓝部分）也切成三行。</li><li>对形成的6个小块，再进行列的切割</li></ol><p>整个做法就是“列-行-列-行-……”这样的交替切割。所以它的对象是这样设置的,其中random属性可以约定同级的cols或rows是否可以随机变换位置，width和height的值是规定一个父级块的分割比例。其设置的形式例如（例子与demo的设定无关）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.tagConfig.pageLayout = &#123;</span><br><span class="line">top: <span class="number">0</span>,</span><br><span class="line">left: <span class="number">0</span>,</span><br><span class="line">width: <span class="number">100</span>,</span><br><span class="line">height: <span class="number">100</span>,</span><br><span class="line">random: !<span class="number">1</span>,</span><br><span class="line">cols: [&#123;</span><br><span class="line">width: <span class="number">30</span>,</span><br><span class="line">rows: [&#123;</span><br><span class="line">height: <span class="number">40</span>,</span><br><span class="line">cols: [&#123;</span><br><span class="line">width: <span class="number">30</span>,</span><br><span class="line">rows:[&#123;</span><br><span class="line">height:<span class="number">100</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">width: <span class="number">70</span>,</span><br><span class="line">rows:[&#123;</span><br><span class="line">height:<span class="number">100</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">height: <span class="number">30</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">height: <span class="number">30</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">width: <span class="number">70</span>,</span><br><span class="line">rows:[&#123;</span><br><span class="line">height:<span class="number">100</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##<strong>二.递归调用切割函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getGrids</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*domArr是拥有left,top,width,height,bg等属性的所有dom数组，_getGrids的最终目的就是生成这个数组*/</span></span><br><span class="line"><span class="keyword">var</span> domArr = [],</span><br><span class="line">_cutGrid(tag.pageLayout,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tag.rows || tag.cols) &#123;</span><br><span class="line"><span class="comment">/*假如子级存在rows或者cols，则递归切割*/</span></span><br><span class="line">_cutGrid(tag, <span class="built_in">arguments</span>.callee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*子级不存在rows或者cols，不再进行切割，构造domArr*/</span></span><br><span class="line">…</span><br><span class="line">domArr.push(xxx)</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> domArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##<strong>三.切割函数</strong></p><p>切割函数挺有意思的，下次想再用一篇文章来详细写一下，在这里仅贴出参考的源码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对象复制函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_shadowClone</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> t = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> e) e.hasOwnProperty(n) &amp;&amp; (t[n] = e[n]);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断子块随机布局与否*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ranOrNot</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> n = [];</span><br><span class="line"><span class="keyword">typeof</span> t == <span class="string">"undefined"</span> &amp;&amp; (t = e, e = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (; e &lt; t; e++) n.push(e);</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*随机布局*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.randomEach = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> t != <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">this</span>.length,</span><br><span class="line">r = ranOrNot(n);</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * n--);</span><br><span class="line"><span class="keyword">if</span> (t(<span class="keyword">this</span>[r[i]]) === !<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">r[i] = r[n]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/*常规布局*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach || (<span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> e != <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>; r &lt; t; r++) r <span class="keyword">in</span> <span class="keyword">this</span> &amp;&amp; e.call(n, <span class="keyword">this</span>[r], r, <span class="keyword">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125; )();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切割函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_cutGrid</span>(<span class="params">tag, funcJudge</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">cutLength</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*复制子块对象并计算出子块top,left*/</span></span><br><span class="line"><span class="keyword">var</span> u, a = _shadowClone(cutLength);</span><br><span class="line">c++,</span><br><span class="line">u = c === l ? tag[cutType2.measure] - s: <span class="built_in">Math</span>.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / <span class="number">100</span>),</span><br><span class="line">a[cutType1.offset] = i + tag[cutType1.offset],</span><br><span class="line">a[cutType2.offset] = s + tag[cutType2.offset],</span><br><span class="line">a[cutType1.measure] = f,</span><br><span class="line">a[cutType2.measure] = u,</span><br><span class="line">a.colorPattern = tag.colorPattern,</span><br><span class="line"><span class="comment">/*判断小块是否还需要分割*/</span></span><br><span class="line">funcJudge(a),</span><br><span class="line">s += u</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f, l = a[cutType2.name].length,</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line">u++,</span><br><span class="line">f = u === cutLength ? tag[cutType1.measure] - i: <span class="built_in">Math</span>.floor(a[cutType1.measure] * tag[cutType1.measure] / <span class="number">100</span>),</span><br><span class="line">a.random === !<span class="number">1</span> ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h),</span><br><span class="line">s = <span class="number">0</span>,</span><br><span class="line">i += f</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*根据大块是否有rows属性，定义两种切割方式*/</span></span><br><span class="line"><span class="keyword">var</span> cutType1, cutType2;</span><br><span class="line">tag.rows ? (cutType1 = &#123;</span><br><span class="line">name: <span class="string">"rows"</span>,</span><br><span class="line">measure: <span class="string">"height"</span>,</span><br><span class="line">offset: <span class="string">"top"</span></span><br><span class="line">&#125;,</span><br><span class="line">cutType2 = &#123;</span><br><span class="line">name: <span class="string">"cols"</span>,</span><br><span class="line">measure: <span class="string">"width"</span>,</span><br><span class="line">offset: <span class="string">"left"</span></span><br><span class="line">&#125;) : (cutType1 = &#123;</span><br><span class="line">name: <span class="string">"cols"</span>,</span><br><span class="line">measure: <span class="string">"width"</span>,</span><br><span class="line">offset: <span class="string">"left"</span></span><br><span class="line">&#125;,</span><br><span class="line">cutType2 = &#123;</span><br><span class="line">name: <span class="string">"rows"</span>,</span><br><span class="line">measure: <span class="string">"height"</span>,</span><br><span class="line">offset: <span class="string">"top"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">s = <span class="number">0</span>,</span><br><span class="line">cutLength = tag[cutType1.name].length,</span><br><span class="line">u = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*是否随机布局*/</span></span><br><span class="line">tag.random === !<span class="number">1</span> ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##<strong>四.最后</strong><br>完成到这一步，我已不记得声明对象时出了多少次错误。各种尖括号，方括号，逗号和分号翩翩起舞时，你一定跟我一样很想念coffee的语法糖…</p>]]></content>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
